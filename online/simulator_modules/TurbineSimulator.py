import random
import matplotlib.pyplot as plt
from .Operators import EXCEEDING, RETURNING
from .Operators import StandardOperator
from .Relations import Link

plt.style.use("seaborn-whitegrid")
plt.rc("figure", autolayout=True, figsize=(11, 4))
plt.rc(
    "axes",
    labelweight="bold",
    labelsize="large",
    titleweight="bold",
    titlesize=16,
    titlepad=10,
)
plot_params = dict(
    color="0.75",
    style=".-",
    markeredgecolor="0.25",
    markerfacecolor="0.25",
)


class Node:
    """
    Represents a node in the simulation graph.

    Attributes:
        operator (StandardOperator): The operator associated with this node.
        name (str): The name of the node.
        root (Node): The parent node.
        edges (list[Edge]): List of edges connecting this node to its children.
        last_value (float): The last value generated by the node.
        stack (list[float]): History of values generated by the node.
    """
    def __init__(self, operator: StandardOperator):
        """
        Initializes the Node with the given operator.

        Parameters:
            operator (StandardOperator): The operator associated with this node.
        """
        self.op = operator
        self.name = operator.name
        self.root = None
        self.edges = []
        self.last_value = None
        self.stack = []

    def add_edge(self, child: "Node", strategy: Link) -> None:
        """
        Adds an edge between this node and a child node.

        Parameters:
            child (Node): The child node.
            strategy (Link): The strategy defining the relationship between the nodes.
        """
        edge = Edge(self, child, strategy=strategy)
        self.edges.append(edge)
        child.root = self
  
    def simulate_component(self, debug: bool = False) -> None:
        """
        Simulates the behavior of this node and its children.

        Parameters:
            debug (bool, optional): Whether to store the generated values in the stack for debugging.
        """
        if self.root is None:
            self.last_value = self.op.next_step()
            if debug:
                self.stack.append(self.last_value)
        for edge in self.edges:
            edge.next_step(debug)
            edge.child.simulate_component(debug)
    
    def plot_history(self, size: tuple = (10, 5)) -> None:
        """
        Plots the history of the node's values.

        Parameters:
            size (tuple, optional): The size of the plot. Defaults to (10, 5).
        """

        if not self.stack:
            raise ValueError("No values to plot. Run the simulation first or enable debug.")

        plt.figure(figsize=size)
        plt.plot(self.stack, label="Values")
        plt.axhline(self.op.typical_value, color="r", linestyle="--", label="Typical Value")
        plt.title(f"Value Stack History: {self.name}")
        plt.xlabel("Steps")
        plt.ylabel("Values")
        plt.legend()
        plt.show()

class Edge:
    """
    Represents an edge between two nodes in the simulation graph.

    Attributes:
        root (Node): The parent node.
        child (Node): The child node.
        strategy (Link): The strategy defining the relationship between the nodes.
    """
    def __init__(self, root: Node, child: Node, strategy: Link):
        """
        Initializes the Edge with the given root, child, and strategy.

        Parameters:
            root (Node): The parent node.
            child (Node): The child node.
            strategy (Link): The strategy defining the relationship between the nodes.
        """
        self.root = root
        self.child = child
        self._strategy = strategy

    @property
    def strategy(self) -> Link:
        """Returns the strategy defining the relationship."""
        return self._strategy

    @strategy.setter
    def strategy(self, strategy: Link) -> None:
        """Sets a new strategy for the edge."""
        self._strategy = strategy
  
    def next_step(self, debug: bool = False) -> None:
        """
        Calculates the next step for the child node based on the strategy.

        Parameters:
            debug (bool, optional): Whether to store the generated values in the child's stack for debugging.
        """
        self.child.last_value = self._strategy.calculate(self.root, self.child)
        if debug:
            self.child.stack.append(self.child.last_value)

class Graph:
    """
    Represents the simulation graph.

    Attributes:
        nodes (list[Node]): List of nodes in the graph.
        current_step (int): The current step in the simulation.
        n_unstable_steps (int): Number of steps to consider as unstable (alert period).
        count (int): Counter for unstable steps.
        last_alert (bool): Whether the last step was is considered an alert.
        alert_period (list[bool]): List indicating alert periods.
        debug (bool): Whether to enable debugging.
    """
    def __init__(self, random_seed:int = None, 
                debug: bool = False, 
                n_unstable_steps: int = 0):
        """
        Initializes the Graph with the given parameters.

        Parameters:
            random_seed (int, optional): Seed for random number generation.
            debug (bool, optional): Whether to enable debugging.
            n_unstable_steps (int, optional): Number of steps to consider as unstable (alert period).
        """
        if random_seed is not None:
            random.seed(random_seed)
        self.nodes = []
        self.current_step = 0
        self.n_unstable_steps = n_unstable_steps
        self.count = 0
        self.is_exceeding_step = []
        self.last_alert = None
        self.alert_period = []
        self.debug = debug

    def add_node(self, operator: StandardOperator) -> Node:
        """
        Adds a node to the graph.

        Parameters:
            operator (StandardOperator): The operator associated with the node.

        Returns:
            Node: The created node.
        """
        node = Node(operator)
        self.nodes.append(node)
        return node

    def add_edge(self, root: Node, child: Node, strategy: Link) -> None:
        """
        Adds an edge between two nodes.

        Parameters:
            root (Node): The parent node.
            child (Node): The child node.
            strategy (Link): The strategy defining the relationship between the nodes.
        """
        root.add_edge(child, strategy)
  
    def simulate(self, steps: int) -> None:
        """
        Simulates the graph for a given number of steps.

        Parameters:
            steps (int): The number of steps to simulate.
        """
        for _ in range(steps):
            self.current_step += 1
            for node in self.nodes:
                if node.root is None:
                    node.simulate_component(self.debug)
                    current_state = node.op.state.get_type()

                    # Generate alert period logic
                    if current_state in (EXCEEDING, RETURNING):
                        self.count = self.n_unstable_steps
                        self.last_alert = True
                        if self.debug:
                            self.alert_period.append(True)
                    elif self.count > 0:
                        self.count -= 1
                        self.last_alert = True
                        if self.debug:
                            self.alert_period.append(True)
                    else:
                        self.last_alert = False
                        if self.debug:
                            self.alert_period.append(False)

    def display(self) -> None:
        """
        Displays the structure of the graph.
        """
        for node in self.nodes:
            print(f'Node {node.name}:', end=' ')
            for edge in node.edges:
                print(f'{edge.child.name}', end=', ')
            print()

    def plot_alert_period(self, node) -> None:
        """
        Plots the alert period for a given node.

        Parameters:
            node (Node): The node to plot the alert period for.
        """
        if not self.debug:
            raise ValueError("Debug mode is not enabled. Set debug=True when creating the graph.")

        plt.figure(figsize=(10, 5))
        plt.plot(node.stack, label=node.name)

        x = list(range(len(node.stack)))
        for i in range(len(self.alert_period)):
            if self.alert_period[i]:
                plt.fill_between([x[i], x[i]], 0, node.stack[i], color='lightblue', alpha=0.5)
        
        plt.title(f"Alert Period for {node.name}")
        plt.xlabel("Steps")
        plt.ylabel("Values")
        plt.legend()
        plt.show()


def plot_nodes_history(nodes: list[Node], range: tuple = None) -> None:
    """
    Plots the history of values for a list of nodes.

    Parameters:
        nodes (list[Node]): The nodes to plot.
        range (tuple, optional): The range of steps to plot. Defaults to None.
    """
    plt.figure(figsize=(10, 5))
    title = ""
    for node in nodes:
        if range:
            start, end = range
            plt.plot(node.stack[start:end], label=node.name)
        else:
            plt.plot(node.stack, label=node.name)
        title += f"{node.name}, "
    plt.title(f"Value Stack History: {title.strip(', ')}")
    plt.xlabel("Steps")
    plt.ylabel("Values")
    plt.legend()
    plt.show()

def plot_sum_history(node_a: Node, node_b: Node) -> None:
    """
    Plots the sum of values for two nodes.

    Parameters:
        node_a (Node): The first node.
        node_b (Node): The second node.
    """
    sum_stack = [ope_1 + ope_2 for ope_1, ope_2 in zip(node_a.stack, node_b.stack)]
    plt.figure(figsize=(10, 5))
    plt.plot(sum_stack, label="Sum of Values", color="green")
    plt.title("Sum of Values Stack History")
    plt.xlabel("Steps")
    plt.ylabel("Values")
    plt.legend()
    plt.show()